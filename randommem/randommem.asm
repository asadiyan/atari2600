    PROCESSOR 6502

    INCLUDE "vcs.h"
    INCLUDE "macro.h"
    
    SEG.U Variables
    ORG $80
Random byte            ; declare Random
Rand1  byte            ; declare Rand1
Rand2  byte            ; declare Rand2
Rand3  byte            ; declare Rand3
Rand4  byte            ; declare Rand4

    SEG code
    ORG $F000          ; define the ROM code origin at $F000

Start:
    CLEAN_START        ; call macro to clear RAM and registers
    SEI                ; disable interrupts
    CLD                ; disable the BCD decimal math mode
    LDX #$FF           ; loads the X register with value #$FF
    TXS                ; transfer X register to S(tack) Pointer

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Initialize variables
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    LDA #%11010100
    STA Random         ; Random = $D4

    LDA #$D4
    STA Rand1
    STA Rand2
    STA Rand3
    STA Rand4          ; Rand1 = Rand2 = Rand3 = Rand4 = $D4

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Puts a random value in the RAM addresses from $81 to $F0
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    LDA #0             ; A = 0
    LDX #$F0           ; X = #$F0

MemLoop:
    TXA                ; since the GetRandomByte routine uses X inside it,
    PHA                ; we are saving X in the stack to be restored later
    
    JSR GetRandomByte  ; call routine to load A with a random byte
    STA Random         ; save the random byte generated by the function
   
    PLA                ; restore the stack value saved previously,
    TAX                ; and put it back to the X register
    
    LDA Random         ; load A with the random byte generated previously
    STA $0,X           ; store the random value at address $0 + X
    DEX                ; X--
    CPX #$80           ; compare X with $80
    BNE MemLoop        ; loop while not equal (until z-flag is set)
    
    STA $0

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Subroutine to generate a random number and save it in the accumulator
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
GetRandomValue SUBROUTINE
    LDA Random
    ASL
    EOR Random
    ASL
    EOR Random
    ASL
    ASL
    EOR Random
    ASL
    ROL Random
    RTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Subrouting to generate random bit
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Rand1, Rand2, Rand3, Rand4 are RAM locations, initialized to any nonzero
;; value at program initialization
;; A random bit is generated by XORing bits 27 and 30 of the register, then
;; shifting the entire thing one bit to the left and placing the new bit on
;; the right. This algorithm produces a sequence of 2^31 - 1 random bits
;; before repeating.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
GetRandomBit SUBROUTINE
    LDA Rand4               ; load accumulator with the value of Rand4
    ASL
    ASL
    ASL
    EOR Rand4               ; new bit is now in bit 6 of A
    ASL
    ASL                     ; new bit is now in carry                               ;<<<<<<<<<<<<<
    ROL Rand1               ; shift new bit to bit 0 of A, bit 7 goes to carry
    ROL Rand2               ; shift old bit 7 into bit 8, etc.
    ROL Rand3
    ROL Rand4
    RTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Subrouting to generate random byte
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Produces 8 random bits and output the result in the accumulator register A
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
GetRandomByte SUBROUTINE
    LDX #8
RandomByteLoop:
    JSR GetRandomBit
    DEX
    BNE RandomByteLoop
    LDA Rand1
    RTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Fill  ROM size to exactly 4KB
;; Also tells 6502 where our program should start (at $FFFC)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ORG $FFFC                   ; move to position $FFFC in memory
    word Start                  ; write 2 bytes with the program reset address
    word Start                  ; write 2 bytes with the interruption vector